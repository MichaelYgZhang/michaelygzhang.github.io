<!DOCTYPE html>
<html>
  <head>
    <title>HashMap JDK1.7 源码分析 – Michael – Developer</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="Java Collections HashMap JDK1.7 源码分析" />
    <meta property="og:description" content="Java Collections HashMap JDK1.7 源码分析" />
    
    <meta name="author" content="Michael" />

    
    <meta property="og:title" content="HashMap JDK1.7 源码分析" />
    <meta property="twitter:title" content="HashMap JDK1.7 源码分析" />
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Michael - Developer" href="/feed.xml" />
    <link rel="shortcut icon" href="/images/favicon.ico" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css"/>
  </head>

  <body>

    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="/images/favicon.ico" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Michael</a></h1>
            <p class="site-description">Developer</p>
          </div>

          <nav>
            <a href="/"><i class="fa fa-home fa-2x"></i></a>
            <a href="/category"><i class="fa fa-tags fa-2x" aria-hidden="true"></i></a>
            <a href="/about"><i class="fa fa-user-secret fa-2x"></i></a>
            <a href="/blog"><i class="fa fa-university fa-2x"></i></a>
            <!-- <a href="/task"><i class="fa fa-book fa-2x" aria-hidden="true"></i></a> -->
            <a href="/feed.xml" target="_blank"><i class="fa fa-feed fa-2x"></i></a>

            <!-- 
            
              
            
              
            
              
              <a href="/" >
                Home
              </a>
              
            
              
              <a href="/blog" >
                Blog
              </a>
              
            
              
              <a href="/category" >
                Category
              </a>
              
             -->
          </nav>

          <a href="https://github.com/MichaelYgZhang" target="_blank">
            <img class="fork-me-on-github" src="/images/fork-me-on-github.png" alt="Fork me on GitHub">
          </a>
        </header>

        <div id="search-container">
          <input type="text" id="search-input" placeholder="search...">
          <ul id="results-container"></ul>
        </div>

      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <div class="post">
    <h1 class="post-title">HashMap JDK1.7 源码分析</h1>
    <span class="post-date">2016-10-13</span>
    <!--  |
    
     -->
    <article>
      <p>HashMap 和 HashSet 是 Java Collection Framework 的两个重要成员，其中 HashMap 是 Map 接口的常用实现类， 简单来说就是底层一个数组+Entry链来实现的。 下面通过源码来进行分析。</p>

<h6 id="hashmap的存储实现">HashMap的存储实现</h6>

<div class="language-java highlighter-rouge"><pre class="highlighter"><code>  <span class="n">HashMap</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>
  <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"first"</span> <span class="o">,</span> <span class="s">"michael"</span><span class="o">);</span>
  <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"last"</span> <span class="o">,</span> <span class="s">"zhang"</span><span class="o">);</span>
</code></pre>
</div>

<p>当程序执行map.put(key,value);方法时。则执行的代码逻辑是:</p>

<div class="language-java highlighter-rouge"><pre class="highlighter"><code>    <span class="kd">public</span> <span class="n">V</span> <span class="nf">put</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">){</span>
        <span class="c1">// 如果 key 为 null，调用 putForNullKey 方法进行处理</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span> <span class="nf">putForNullKey</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
        <span class="c1">// 根据 key 的 hashCode 计算 Hash 值</span>
        <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
        <span class="c1">// 搜索指定 hash 值在对应 table 中的索引</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">indexFor</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">table</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="c1">// 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Entry</span> <span class="n">e</span> <span class="o">=</span> <span class="n">table</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="n">Object</span> <span class="n">k</span><span class="o">;</span>
            <span class="c1">// 找到指定 key 与需要放入的 key 相等(hash 值相同通过 equals 比较返回 true)则覆盖oldValue(与HashSet不同,HashSet不会覆盖,</span>
            <span class="c1">//HashSet调用的方法set.add(Object e);</span>
            <span class="c1">//其实就是public boolean add(E e) {</span>
	          <span class="c1">// return map.put(e, PRESENT)==null;//注意e,是key值</span>
            <span class="c1">// })</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">)))</span>
                <span class="o">{</span>
                    <span class="n">V</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">recordAccess</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
                    <span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
                <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// 如果 i 索引处的 Entry 为 null，表明此处还没有 Entry, modCount记录HashMap中修改结构的次数</span>
        <span class="n">modCount</span><span class="o">++;</span>
        <span class="c1">// 将 key、value 添加到 i 索引处</span>
        <span class="n">addEntry</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre>
</div>

<ul>
  <li>
    <p>根据上面 put 方法的源代码可以看出，当程序试图将一个 key-value 对放入 HashMap 中时，程序首先根据该 key 的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同， 那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry 的 value，但 key 不会覆盖。 如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。 当向 HashMap 中添加 key-value 对，由其 key 的 hashCode() 返回值决定该 key-value 对（就是 Entry 对象）的存储位置。当两个 Entry 对象的 key 的 hashCode() 返回值相同时， 将由 key 通过 eqauls() 比较值决定是采用覆盖行为（返回 true），还是产生 Entry 链（返回 false）。</p>
  </li>
  <li>
    <p>程序中调用 indexFor(int h, int length) 方法来计算该对象应该保存在 table 数组的哪个索引处。indexFor(int h, int length) 方法的代码如下：</p>
  </li>
</ul>

<div class="language-java highlighter-rouge"><pre class="highlighter"><code>  <span class="kd">static</span> <span class="kt">int</span> <span class="nf">indexFor</span><span class="o">(</span><span class="kt">int</span> <span class="n">h</span><span class="o">,</span> <span class="kt">int</span> <span class="n">length</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">h</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
  <span class="o">}</span>
</code></pre>
</div>

<ul>
  <li>
    <p>注解:该方法总是通过 h &amp;(table.length -1) 来得到该对象的保存位置——而 HashMap 底层数组的长度总是 2 的 n 次方，这一点可参看后面关于 HashMap 构造器的介绍。 当 length 总是 2 的倍数时，h &amp; (length-1)将是一个非常巧妙的设计：假设 h=5,length=16, 那么 h &amp; length - 1 将得到 5； 如果 h=6,length=16, 那么 h &amp; length - 1 将得到 6 ……如果 h=15,length=16, 那么 h &amp; length - 1 将得到 15； 但是当 h=16 时 , length=16 时，那么 h &amp; length - 1 将得到 0 了；当 h=17 时 , length=16 时，那么 h &amp; length - 1 将得到 1 了…… 这样保证计算得到的索引值总是位于 table 数组的索引之内。</p>
  </li>
  <li>
    <p>put方法中 addEntry 是 HashMap 提供的一个包访问权限的方法，该方法仅用于添加一个 key-value 对。下面是该方法的代码：</p>
  </li>
</ul>

<div class="language-java highlighter-rouge"><pre class="highlighter"><code>    <span class="kt">void</span> <span class="nf">addEntry</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">int</span> <span class="n">bucketIndex</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="c1">// 获取指定 bucketIndex 索引处的 Entry</span>
        <span class="n">Entry</span> <span class="n">e</span> <span class="o">=</span> <span class="n">table</span><span class="o">[</span><span class="n">bucketIndex</span><span class="o">];</span>
        <span class="c1">// 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry,此时将会形成一个Entry链</span>
        <span class="n">table</span><span class="o">[</span><span class="n">bucketIndex</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Entry</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
        <span class="c1">// 如果 Map 中的 key-value 对的数量超过了极限</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">size</span><span class="o">++</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="o">)</span>
        <span class="c1">// 把 table 对象的长度扩充到 2 倍。</span>
        <span class="n">resize</span><span class="o">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">table</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre>
</div>

<h5 id="存储示意图">存储示意图</h5>

<p><img src="https://raw.githubusercontent.com/MichaelYgZhang/home/gh-pages/images/hash.jpg" alt="" /></p>

<h5 id="hashmap的读取实现">HashMap的读取实现</h5>

<div class="language-java highlighter-rouge"><pre class="highlighter"><code>    <span class="kd">public</span> <span class="n">V</span> <span class="nf">get</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="c1">// 如果 key 是 null，调用 getForNullKey 取出对应的 value</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span> <span class="nf">getForNullKey</span><span class="o">();</span>
        <span class="c1">// 根据该 key 的 hashCode 值计算它的 hash 码</span>
        <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
        <span class="c1">// 直接取出 table 数组中指定索引处的值，</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Entry</span> <span class="n">e</span> <span class="o">=</span> <span class="n">table</span><span class="o">[</span><span class="n">indexFor</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">table</span><span class="o">.</span><span class="na">length</span><span class="o">)];</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
                        <span class="c1">// 搜索该 Entry 链的下一个 Entr</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="n">Object</span> <span class="n">k</span><span class="o">;</span>
            <span class="c1">// 如果该 Entry 的 key 与被搜索 key 相同</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">)))</span>
                <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre>
</div>

<ul>
  <li>总结:HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对， 当需要存储一个 Entry 对象时，会根据 Hash 算法来决定其存储位置；当需要取出一个 Entry 时，也会根据 Hash 算法找到其存储位置，直接取出该 Entry。 由此可见：HashMap 之所以能快速存、取它所包含的 Entry， 完全类似于,不同的东西要放在不同的位置，需要时才能快速找到它。</li>
</ul>

<h5 id="hashmap中hash算法的性能控制">HashMap中Hash算法的性能控制</h5>

<ul>
  <li>首先了解HashMap的构造方法： HashMap()：构建一个初始容量为 16，负载因子为 0.75 的 HashMap。HashMap(int initialCapacity)：构建一个初始容量为 initialCapacity，负载因子为 0.75 的 HashMap。HashMap(int initialCapacity, float loadFactor)：以指定初始容量、指定的负载因子创建一个 HashMap。</li>
</ul>

<div class="language-java highlighter-rouge"><pre class="highlighter"><code>    <span class="c1">// 以指定初始化容量、负载因子创建 HashMap</span>
   <span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">,</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">)</span>
   <span class="o">{</span>
       <span class="c1">// 初始容量不能为负数</span>
       <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
           <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span>
               <span class="s">"Illegal initial capacity: "</span> <span class="o">+</span>
               <span class="n">initialCapacity</span><span class="o">);</span>
       <span class="c1">// 如果初始容量大于最大容量，让出示容量</span>
       <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&gt;</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span>
           <span class="n">initialCapacity</span> <span class="o">=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">;</span>
           <span class="c1">// 负载因子必须大于 0 的数值</span>
       <span class="k">if</span> <span class="o">(</span><span class="n">loadFactor</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">Float</span><span class="o">.</span><span class="na">isNaN</span><span class="o">(</span><span class="n">loadFactor</span><span class="o">))</span>
           <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="n">loadFactor</span><span class="o">);</span>
       <span class="c1">// 计算出大于 initialCapacity 的最小的 2 的 n 次方值。</span>
       <span class="kt">int</span> <span class="n">capacity</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
       <span class="k">while</span> <span class="o">(</span><span class="n">capacity</span> <span class="o">&lt;</span> <span class="n">initialCapacity</span><span class="o">)</span>
           <span class="n">capacity</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="o">;</span>
       <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">loadFactor</span><span class="o">;</span>
       <span class="c1">// 设置容量极限等于容量 * 负载因子</span>
       <span class="n">threshold</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">capacity</span> <span class="o">*</span> <span class="n">loadFactor</span><span class="o">);</span>
       <span class="c1">// 初始化 table 数组</span>
       <span class="n">table</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Entry</span><span class="o">[</span><span class="n">capacity</span><span class="o">];</span>
       <span class="n">init</span><span class="o">();</span>
   <span class="o">}</span>
</code></pre>
</div>

<ul>
  <li>注解:table 的实质就是一个数组，一个长度为 capacity 的数组。当系统开始初始化 HashMap 时，系统会创建一个长度为 capacity 的 Entry 数组， 这个数组里可以存储元素的位置被称为“桶（bucket）”，每个 bucket 都有其指定索引，系统可以根据其索引快速访问该 bucket 里存储的元素。 无论何时，HashMap 的每个“桶”只存储一个元素（也就是一个 Entry），由于 Entry 对象可以包含一个引用变量（就是 Entry 构造器的的最后一个参数） 用于指向下一个 Entry，因此可能出现的情况是：HashMap 的 bucket 中只有一个 Entry，但这个 Entry 指向另一个 Entry ——这就形成了一个 Entry 链。</li>
  <li>initialCapacity：HashMap的最大容量，即为底层数组的长度。</li>
  <li>loadFactor：负载因子loadFactor定义为：散列表的实际元素数目(n)/ 散列表的容量(m)。
负载因子衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。 对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分， 然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。 HashMap的实现中，通过threshold字段来判断HashMap的最大容量：threshold = (int)(capacity * loadFactor); 结合负载因子的定义公式可知，threshold就是在此loadFactor和capacity对应下允许的最大元素数目，超过这个数目就重新resize， 以降低实际的负载因子。默认的的负载因子0.75是对空间和时间效率的一个平衡选择。 当threshold超出此最大容量时， 修改resize后的HashMap容量是容量的两倍。 其实就是对Table数组的扩容，原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</li>
</ul>

<h5 id="key的hashcode与equals方法的重写">Key的hashCode()与equals()方法的重写</h5>

<p>在map.put(key,value);中首先是对key进行hashCode()取值,然后通过hash()取值，得到元素在数组中的位置，之后进行key的equals(); 方法，找到该链表中的所需元素。可以看出hashCode(),equals()在put(),get(),方法中都是关键方法。所以为了保证存取对象时的正确性，要修改其 hashCode()以及equals()方法。</p>

<h5 id="fail-fast策略速错">Fail-Fast策略（速错）</h5>

<p>java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException， 这就是所谓fail-fast策略（速错），这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数， 对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。</p>

<div class="language-java highlighter-rouge"><pre class="highlighter"><code>    <span class="kd">private</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">HashIterator</span> <span class="kd">implements</span> <span class="n">Iterator</span> <span class="o">{</span>
        <span class="n">Entry</span> <span class="n">next</span><span class="o">;</span>        <span class="c1">// next entry to return</span>
        <span class="kt">int</span> <span class="n">expectedModCount</span><span class="o">;</span>   <span class="c1">// For fast-fail</span>
        <span class="kt">int</span> <span class="n">index</span><span class="o">;</span>              <span class="c1">// current slot</span>
        <span class="n">Entry</span> <span class="n">current</span><span class="o">;</span>     <span class="c1">// current entry</span>

        <span class="n">HashIterator</span><span class="o">()</span> <span class="o">{</span><span class="c1">//Hash迭代</span>
            <span class="n">expectedModCount</span> <span class="o">=</span> <span class="n">modCount</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// advance to first entry</span>
                <span class="n">Entry</span><span class="o">[]</span> <span class="n">t</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">next</span> <span class="o">=</span> <span class="n">t</span><span class="o">[</span><span class="n">index</span><span class="o">++])</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">final</span> <span class="n">Entry</span> <span class="nf">nextEntry</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">modCount</span> <span class="o">!=</span> <span class="n">expectedModCount</span><span class="o">)</span><span class="c1">//如果不相等就表示被其他线程修改过map</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ConcurrentModificationException</span><span class="o">();</span>
            <span class="n">Entry</span> <span class="n">e</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoSuchElementException</span><span class="o">();</span>

            <span class="k">if</span> <span class="o">((</span><span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">Entry</span><span class="o">[]</span> <span class="n">t</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">next</span> <span class="o">=</span> <span class="n">t</span><span class="o">[</span><span class="n">index</span><span class="o">++])</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="o">;</span>
            <span class="o">}</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">e</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">modCount</span> <span class="o">!=</span> <span class="n">expectedModCount</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ConcurrentModificationException</span><span class="o">();</span>
            <span class="n">Object</span> <span class="n">k</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">key</span><span class="o">;</span>
                <span class="n">current</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">HashMap</span><span class="o">.</span><span class="na">this</span><span class="o">.</span><span class="na">removeEntryForKey</span><span class="o">(</span><span class="n">k</span><span class="o">);</span>
            <span class="n">expectedModCount</span> <span class="o">=</span> <span class="n">modCount</span><span class="o">;</span>
        <span class="o">}</span>

    <span class="o">}</span>
</code></pre>
</div>

<ul>
  <li>在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了map。 注意到modCount声明为volatile，保证线程之间修改的可见性。（volatile之所以线程安全是因为被volatile修饰的变量不保存缓存，直接在内存中修改，因此能够保证线程之间修改的可见性）。</li>
</ul>

    </article>
  </div>

  <div class="related">
    <h4>最新文章</h4>
    <ul class="related-posts">
      
        <li>
          <h5>
            <a href="/books/2017/08/18/%E5%86%85%E5%90%91%E8%80%85%E4%BC%98%E5%8A%BF.html">
              内向者优势
              <small>2017-08-18</small>
            </a>
          </h5>
        </li>
      
        <li>
          <h5>
            <a href="/architecture/2017/08/10/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html">
              亿级流量网站架构核心技术
              <small>2017-08-10</small>
            </a>
          </h5>
        </li>
      
        <li>
          <h5>
            <a href="/architecture/2017/07/26/%E9%87%8D%E6%9E%84%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1.html">
              重构-改善既有代码的设计
              <small>2017-07-26</small>
            </a>
          </h5>
        </li>
      
    </ul>
  </div>

  
<div class="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript">

	    var disqus_shortname = 'michaelygzhangblog';

	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();

	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          
<a href="mailto:g.zhangyg@gmail.com"><i class="svg-icon email"></i></a>


<a href="https://github.com/MichaelYgZhang"><i class="svg-icon github"></i></a>




<a href="https://www.twitter.com/michaelygzhang"><i class="svg-icon twitter"></i></a>


<a href="https://plus.google.com/115646538142388831563"><i class="svg-icon googleplus"></i></a>

        </footer>
      </div>
    </div>

    <div id="backToTop" class="backtoTop">
    	<i class="fa fa-hand-o-up fa-2x"></i>
    </div>

    
	<!-- Google Analytics -->
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-84531968-1', 'auto');
		ga('send', 'pageview', {
		  'page': '/java/2016/10/13/java-collection-hashmap-jdk17.html',
		  'title': 'HashMap JDK1.7 源码分析'
		});
	</script>
	<!-- End Google Analytics -->


    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js" type="text/javascript"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simple-jekyll-search/1.1.5/jekyll-search.js" type="text/javascript"></script>
    <script src="/js/blog.js" type="text/javascript"></script>

    <script type="text/javascript">
          SimpleJekyllSearch({
            searchInput: document.getElementById('search-input'),
            resultsContainer: document.getElementById('results-container'),
            json: '/search.json',
            searchResultTemplate: '<li><a href="{url}" title="{desc}">{title}</a></li>',
            noResultsText: 'No results found',
            limit: 10,
            fuzzy: false,
            exclude: ['Welcome']
          })
    </script>
  </body>
</html>
