---
layout: post
title: Java Concurrency in Paractice 第三部分  活跃性、性能与测试
excerpt: Java Concurrency in Paractice 第十章 避免活跃性危险 第十一章 性能与可伸缩性
category: Java
---

##### 避免活跃性危险

- 如果在持有锁时调用某个外部方法，那么将出现活跃性问题，在这个外部方法中可能获取其他锁（这可能会产生死锁），或者阻塞时间过长，导致其他线程无法及时获得当前被持有的锁。
- 如果在调用某个方法时不需要持有锁，那么这种调用被称为开放调用（Open Call）。可以通过这种方式调用来避免死锁。
- 在程序中应尽量使用开放调用。与那些在持有锁时调用外部方法的程序相比，更易于依赖于开放调用的程序进行死锁分析。
- 要避免使用线程优先级，因为这会增加平台依赖性，并可能导致活跃性问题，在大多数并发应用程序中，都可以使用默认的线程优先级。
- 活跃性故障是一个非常严重的问题，因为当出现活跃性故障时，除了中止应用程序之外没有其他任何机制可以帮助从这种故障时恢复过来。最常见的活跃性故障就是
  锁顺序死锁。在设计时应该避免产生锁顺序死锁，确保线程在获取多个锁时采用一致的顺序，最好的解决方法是在程序中使用使用开放调用。这将大大减少需要同时持有
  多个锁的地方，也更容易发现这些地方。

##### 性能与可伸缩性

- TODO
