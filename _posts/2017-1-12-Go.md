---
layout: post
title: Go语言编程
excerpt: Go Programe Language
category: Go
---

#### 第1章 初始Go语言

- 贝尔实验室-Limbo编程语言-Go
- 2012年第一个正式版本Go发布Google开源
- 语言特性
  - GC
  - 丰富的内置类型 (简单内置类型，字典类型map,新增数据类型：数组切片(Slice),减少导入包)
  - 函数多个返回值

```go
  func getName()(firstName, middleName, lastName, nickName string){
    return "May", "M", "Chen", "Babe"
  }
  fn, mn, ln, nn := getName()
  // _, _, lastName, _ := getName()
```

  - 错误处理 (defer, panic, recover,可以减少代码量无需try-catch,方便阅读和维护)
  - 匿名函数和闭包

```go
  f := func(x, y int) int {
    return x +　y
  }
```

  - 类型和接口(不支持继承和重载,支持基本类型组合功能)

```go
//比如java在实现一个接口之前必须先定义该接口，并且将类型和接口紧密绑定，即接口的修改会影响到所有实现类,GO的接口体系避免了这类问题
  type Bird struct {
    // ....
  }
  func (b *Bird) Fly() {
    //以鸟的方式飞行
  }
  type IFly interface {
      Fly()
  }
  func main() {
    var fly IFly = new (Bird)
    fly.Fly()
  }
//虽然Bird类型实现的时候没有生命与接口IFly的关系，但接口和类型可以直接转换，甚至接口的定义都不用在类型定义之前，这种比较松散的对应关系可以大幅降低因为接口调整而导致的大量代码调整工作。  
```  
  - 并发编程
    - goroutine:使得并发编程非常简单。使用gorutine而不是裸用操作系统的并发机制，以及使用消息传递来共享内存而不是使用共享内存来通信。[](https://my.oschina.net/xinxingegeya/blog/364693)
    goroutine是一种比线程更轻盈、省资源的协程。使用关键字go执行。

```go
  //goroutine和channel实例,两个goroutine并行累加计算，待两个计算过程完成后打印计算结果
  package main
  import "fmt"
  func sum(values [] int, resultChan chan int) {
    sum := 0
    for _, value := range values {
      sum += value
    }
    resultChan <- sum //将计算结果发送到channel中
  }

  func main () {
    values := [] int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    resultChan := make(chan int, 2)
    go sum(values[:len(values)/2], resultChan)
    go sum(values[len[(values)/2]:], resultChan)
    sum1, sum2 := <-resultChan, <-resultChan //接收结果
    fmt.Println("Result:", sum1, sum2, sum1 + sum2)
  }

```    

  - 反射(反射最常见的使用场景是做对象的序列化（serialization，有时候也叫Marshal & Unmarshal）。例如，Go语言标准库的encoding/json、encoding/xml、encoding/gob、encoding/binary等包就大量依赖于反射功能来实现。)

  - 语言交互性 (Cgo指的是与C语言的混合特性与Java的JNI不同,更简单)

```go
    package main
    /*
    #include <stdio.h>
    */
    import "C"
    import "unsafe"
    func main () {
      cstr := C.CString("Hello, word")
      C.puts(cstr)
      C.free(unsafe.Pointer(cstr))
    }
```

- Go Helloword

```go
  package main   //所属包
  import "fmt"   // 导入依赖包,不得导入没有使用到的包,否则Go便以其器报编译错误
  func main () { //可执行入口
    fmt.Println("Hello, world")
  }

  //Go 函数定义
  func 函数名 (参数列表) (返回值列表) {
    //函数体
  }
  func Comput (value int, value2 float64) (result float64, err error) {
    //函数体
  }

  //go 注释
  /*
  块注释
  */
  // 行注释
  //Go没有分号
  //左花括号 { 不允许另起一行放置
```

- Go版本-编译-运行
  - $ go version  # go version go1
  - $ go run hello.go # 直接运行(编译、链接、运行合为一步,不会产生中间文件盒可执行文件)
  - $ go build hello.go
  - $ ./hello
  - go test  xxx
- [Go资料](http://github.com/wonderfo/wonderfogo/wiki)

#### 第2章 顺序编程

- 变量

```go
  var v1 int
  var v2 string
  var v3 [10]int  //数组
  var v4 []int    //数组切片
  var v5 struct {
    f int
  }
  var v6 *int   //指针
  var v7 map[string]int  //map, key为string类型,value为int类型
  var v8 func(a int) int

  var (
    v1 int
    v2 string
  )

  //初始化
  var v1 int = 10
  var v2 = 10   //编译器可以推导出v2类型
  v3 := 10      //编译器可以推导出v2类型
  //注意: 出现在:=左侧的变量不应该是已经被声明过的，否则会导致编译错误

  //变量赋值
  var v10 int
  v10 = 123
  //多重赋值
  i, j = j, i //交换i和j变量,否则需要引入中间变量才能交换,比如 t = i; i = j; j = t;  使用得到可以减少代码行数
```  

- 常量编译期间就已知且不可改变的值。常量可以使整型、浮点和复数、布尔、字符串类型

```go
  //常量定义
  const PI float64 = 3.1415926
  const zero = 0.0    //无类型浮点常量
  const (
    size int64 = 1024
    eof = -1
  )
  const u, v float32 = 0, 3 //u=0.0, v=3.0 多重赋值
  const a, b, c = 3, 4, "foo" //a=3, b=4, c="foo"
  const mask = 1 << 3
  //注意:常量的赋值是一个编译期行为,所以右值不能出现任何需要运行期才能得出结果的表达式
  const Home = os.GetEnv("Home") //编译错误

  //预定义常量 : true、false、1ota(可被编译器修改的常量,在么一个const关键字出现时被重置为0，然后在下一个const出现之前，每出现一次1ota，其所代表的数字自动增1)
  const (           // 1ota被重设置为0
    c0 = 1ota       // c0 == 0
    c1 = 1ota       // c1 == 1
    c2 = 1ota       // c2 == 2
  )
  //如果两个const的赋值语句的表达式是一样的，那么可以省略后一个赋值表达式。因此，上面的语句可以简写为:
  const (           // 1ota被重设置为0
    c0 = 1ota       // c0 == 0
    c1              // c1 == 1
    c2              // c2 == 2
  )
// 枚举
  const (
    Sumday = 1ota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Staturday
    numberOfDays
    //以大写字母开头的常量在包外可见,以上例子中numberOfDays为包内私有,其他符号则可被其他包访问
  )  

```

- 类型
  - 布尔类型 : bool
  - 整型: int8、byte、int16、int、uint、uintptr等
  - 浮点类型: float32、float64
  - 复数类型: complex64、complex128
  - 字符串: string
  - 字符类型: rune
  - 错误类型: error
  - 复合类型:
    - 指针 pointer
    - 数组 array
    - 切片 slice
    - 字典 map
    - 通道 chan
    - 结构体 struct
    - 接口 interface

- 布尔类型:

```go
  var v1 bool
  v1 = true
  v2 := (1 == 2)  //v2 也会被推导为bool类型
```  

- 整型
- 浮点数
- 复数类型
- 字符串
- 数组
- map
- 流程控制
  - 选择
  - 循环
  - 跳转
  - 条件语句  if、else和else if
  - 选择语句  switch， case select
  - 循环语句  for和range
  - 跳转语句 goto
- 循环语句

```go
  sum := 0
  for i := 0; i < 10; i++ {
      sum += 1
  }
//无限循环
  sum := 0
  for {
    sum++
    if sum > 100 {
      break
    }
  }
// 除了支持continue和break，还有更高级的break
for j := 0; j < 5; j++ {
    for i := 0; i < 10; i++ {
      if i > 5 {
        break JLoop
      }
      fmt.Println(i)
    }
}  

JLoop:
//... break语句终止的是JLoop标签处的外层循环

```

- 跳转语句 goto

```go
func myFunc() {
  i := 0
  HERE:
  fmt.Println(i)
  i++
  if i < 10 {
    goto HERE
  }
}
```

- 函数

```go
func Add(a int, b int) (ret int, err error) {
  if a < 0 || b < 0 {
    err = errors.New("Should be non-negative numbers!")
    return
  }
  return a + b, nil // 支持多重返回值
}

//函数调用
//....
import "mymath"  //假设Add被放在 mymath包中
c := mymath.Add(1, 2)

```

##### 注意: 小写字母开头的函数只在本包内可见，大写字母开头的函数才能被其他包使用。这个规则也同样适用于类型和变量的可见性。

- 不定参数

```go
func myfunc(args ...int) {
	for _, arg := range args {
		fmt.Println(arg)
	}
}

//任意类型的不定参数
func Print(format string, args ...interface{}) {
  //....
}
```

- 多返回值

- 匿名函数与闭包

- 闭包：闭包是可以包含自由(未绑定到特定对象)变量的代码块，这些变量不再这个代码块内或者任何全局上下文中定义，而是在定义代码块的环境中定义。要执行的代码块(由于自由变量包含在代码块中，所以这些自由变量以及他们引用的对象没有被释放)为自由变量提供绑定的计算环境(作用域)。
- 闭包的价值:在于可以作为函数对象或者匿名函数，对于类型系统而言，这意味着不仅要表示数据还要表示代码。支持闭包的多数语言都将函数作为第一级对象，就是说这些函数可以存储到变量中作为参数传递给其他函数，最重要的是能够被函数动态创建和返回。
- 错误处理
  - error接口
  - defer
- panic(), recover()

#### 第3章 面向对象编程

- 类型系统
- 结构体 struct
- p83
