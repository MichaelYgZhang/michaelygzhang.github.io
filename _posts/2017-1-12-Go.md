---
layout: post
title: Go语言编程
excerpt: Go Programe Language
category: Go
---

#### 第1章 初始Go语言

- 贝尔实验室-Limbo编程语言-Go
- 2012年第一个正式版本Go发布Google开源
- 语言特性
  - GC
  - 丰富的内置类型 (简单内置类型，字典类型map,新增数据类型：数组切片(Slice),减少导入包)
  - 函数多个返回值

```go
  func getName()(firstName, middleName, lastName, nickName string){
    return "May", "M", "Chen", "Babe"
  }
  fn, mn, ln, nn := getName()
  // _, _, lastName, _ := getName()
```

  - 错误处理 (defer, panic, recover,可以减少代码量无需try-catch,方便阅读和维护)
  - 匿名函数和闭包

```go
  f := func(x, y int) int {
    return x +　y
  }
```

  - 类型和接口(不支持继承和重载,支持基本类型组合功能)

```go
//比如java在实现一个接口之前必须先定义该接口，并且将类型和接口紧密绑定，即接口的修改会影响到所有实现类,GO的接口体系避免了这类问题
  type Bird struct {
    // ....
  }
  func (b *Bird) Fly() {
    //以鸟的方式飞行
  }
  type IFly interface {
      Fly()
  }
  func main() {
    var fly IFly = new (Bird)
    fly.Fly()
  }
//虽然Bird类型实现的时候没有生命与接口IFly的关系，但接口和类型可以直接转换，甚至接口的定义都不用在类型定义之前，这种比较松散的对应关系可以大幅降低因为接口调整而导致的大量代码调整工作。  
```  
  - 并发编程
    - goroutine:使得并发编程非常简单。使用gorutine而不是裸用操作系统的并发机制，以及使用消息传递来共享内存而不是使用共享内存来通信。[消息共享区别](https://my.oschina.net/xinxingegeya/blog/364693)
    goroutine是一种比线程更轻盈、省资源的协程。使用关键字go执行。

```go
  //goroutine和channel实例,两个goroutine并行累加计算，待两个计算过程完成后打印计算结果
  package main
  import "fmt"
  func sum(values [] int, resultChan chan int) {
    sum := 0
    for _, value := range values {
      sum += value
    }
    resultChan <- sum //将计算结果发送到channel中
  }

  func main () {
    values := [] int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    resultChan := make(chan int, 2)
    go sum(values[:len(values)/2], resultChan)
    go sum(values[len[(values)/2]:], resultChan)
    sum1, sum2 := <-resultChan, <-resultChan //接收结果
    fmt.Println("Result:", sum1, sum2, sum1 + sum2)
  }

```    

  - 反射(反射最常见的使用场景是做对象的序列化（serialization，有时候也叫Marshal & Unmarshal）。例如，Go语言标准库的encoding/json、encoding/xml、encoding/gob、encoding/binary等包就大量依赖于反射功能来实现。)

  - 语言交互性 (Cgo指的是与C语言的混合特性与Java的JNI不同,更简单)

```go
    package main
    /*
    #include <stdio.h>
    */
    import "C"
    import "unsafe"
    func main () {
      cstr := C.CString("Hello, word")
      C.puts(cstr)
      C.free(unsafe.Pointer(cstr))
    }
```

- Go Helloword

```go
  package main   //所属包
  import "fmt"   // 导入依赖包,不得导入没有使用到的包,否则Go便以其器报编译错误
  func main () { //可执行入口
    fmt.Println("Hello, world")
  }

  //Go 函数定义
  func 函数名 (参数列表) (返回值列表) {
    //函数体
  }
  func Comput (value int, value2 float64) (result float64, err error) {
    //函数体
  }

  //go 注释
  /*
  块注释
  */
  // 行注释
  //Go没有分号
  //左花括号 { 不允许另起一行放置
```

- Go版本-编译-运行
  - $ go version  # go version go1
  - $ go run hello.go # 直接运行(编译、链接、运行合为一步,不会产生中间文件盒可执行文件)
  - $ go build hello.go
  - $ ./hello
  - go test  xxx
- [Go资料](http://github.com/wonderfo/wonderfogo/wiki)

#### 第2章 顺序编程

- 变量

```go
  var v1 int
  var v2 string
  var v3 [10]int  //数组
  var v4 []int    //数组切片
  var v5 struct {
    f int
  }
  var v6 *int   //指针
  var v7 map[string]int  //map, key为string类型,value为int类型
  var v8 func(a int) int

  var (
    v1 int
    v2 string
  )

  //初始化
  var v1 int = 10
  var v2 = 10   //编译器可以推导出v2类型
  v3 := 10      //编译器可以推导出v2类型
  //注意: 出现在:=左侧的变量不应该是已经被声明过的，否则会导致编译错误

  //变量赋值
  var v10 int
  v10 = 123
  //多重赋值
  i, j = j, i //交换i和j变量,否则需要引入中间变量才能交换,比如 t = i; i = j; j = t;  使用得到可以减少代码行数
```  

- 常量编译期间就已知且不可改变的值。常量可以使整型、浮点和复数、布尔、字符串类型

```go
  //常量定义
  const PI float64 = 3.1415926
  const zero = 0.0    //无类型浮点常量
  const (
    size int64 = 1024
    eof = -1
  )
  const u, v float32 = 0, 3 //u=0.0, v=3.0 多重赋值
  const a, b, c = 3, 4, "foo" //a=3, b=4, c="foo"
  const mask = 1 << 3
  //注意:常量的赋值是一个编译期行为,所以右值不能出现任何需要运行期才能得出结果的表达式
  const Home = os.GetEnv("Home") //编译错误



```
