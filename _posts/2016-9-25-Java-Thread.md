---
layout: post
title: Java Thread
excerpt: Java 多线程
category: Java
---

- 多线程指的是这个程序(一个进程)运行时产生了不止一个线程。
- 并行与并发

> - 并行:多个`cpu`实例或者多台机器同时执行一段处理逻辑,真正的同时。
> - 并发:通过`cpu`调度算法，让用户看上去同时执行，实际从`cpu`操作层面上看不是真正的同时。并发往往在场景中有公用资源，那么针对这个公用的资源往往产生瓶颈，我们用`TPS`或者`QPS`来反应这个系统的处理能力。

- 线程安全:经常用来描述一段代码。指在并发的情况下该代码经过多线程的使用，线程的调度顺序不能影响任何结果。这个时候使用多线程，我们只需要关注系统的内存,`cpu`是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终的结果，如不加事务的转账代码:

```java
vodi transferMoney(User from, User to, float amount){
    to.setMoney(to.getBlance() + amount);
    from.setMoney(from.getBlance() - amount);
}
```

- 同步:Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面代码简单加入`@synchronized`关键字。在保证结果准确的同时，提高性能，才是优秀的程序，县城安全的优先级高于性能。

**线程状态:**

*Java线程一共有七个状态，分别是新建，可运行，运行中，睡眠，阻塞，等待，死亡。*

- 新建状态`New`:新创建一个线程对象
- 就绪状态`Runable`:线程对象创建后，其他线程调用了该对象的`start()`方法。该状态的线程位于线程池中，变得可运行，等待获取`CPU`的使用权。
- 运行状态`Running`:就绪状态的线程获取了`CPU`，执行程序代码。
- 阻塞状态`Blocked`:阻塞状态是线程因为某种原因放弃`CPU`使用权，暂时停止运行，直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种:

> 1. 等待阻塞:运行的线程执行`wait()`方法，JVM会把该线程放入等待池中(进入这个状态会释放所占有的所有资源，与阻塞状态不同)。
> 3. 同步阻塞:运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
> 4. 其他阻塞:运行的线程执行`sleep()或join()`或者发出了I/O请求时，JVM会把该线程置为阻塞状态(该状态既停止当前线程，但并不释放所占有的资源)。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。

- 线程调用`yield()`意思是放弃当前获得的CPU时间片，回到可运行状态，这时与其它线程处于同等竞争状态，OS有可能接着又让这个线程进入运行状态
- 死亡状态`Dead`:线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

![线程状态图](http://ifeve.com/wp-content/uploads/2014/08/threads2.gif)
