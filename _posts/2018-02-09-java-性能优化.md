---
layout: post
title: Java性能优化
excerpt: Java性能优化
category: Java
---

> 部分代码在不同的JDK版本可能会有出入

#### 第1章 Java性能调优概述
##### 评价性能的主要指标，`服务器响应时间``服务器吞吐量`
- 程序性能关键指标:`执行响应时间``内存分配``启动时间``负载承受能力``CPU占用时间``磁盘I/O吞吐量``网络吞吐量`
- 木桶原理的概念及其在性能优化中的应用，即对系统中响应时间最差的进行优化。一般来讲`内存读写 > 本地磁盘I/O > 网络I/O`, 主要看任务是`CPU密集`还是`I/O密集`,异常捕获和处理非常消耗计算机资源，数据库读写瓶颈,锁竞争会增加线程上下文切换开销白白占用CPU资源。内存。以上是在木桶原理中可能的短板块。
- `Amdahl`定律，使用多核CPU对系统进行优化,优化的效果取决于对CPU的数量以及系统中的串行化程序的比重，CPU数量越多，串行化比重越低，则优化效果越好，仅提高CPU数量而不降低程序的串行化比重，也无法提高系统性能。
- 性能调优的层次,`设计调优:处于最上层,好的系统设计可以规避很多潜在的性能问题,所以尽可能多花些时间在系统设计上是创建高性能程序的关键`，`代码调优微观也是产生最直接的优化方法`，`JVM调优`，`数据库调优,SQL优化,数据库表优化拆解合并`,`操作系统调优,共享内存段信号量,共享内存最大值,共享内存最小值,最大文件句柄数,磁盘的块大小等`
- 系统优化的一般步骤和注意事项.

> 系统优化步骤: 1. 明确优化目标(吞吐量/响应时间..) 2. 测试 3. 是否达到目标,Yes则终止,No则继续4. 4. 查找瓶颈 5. 改进实现(修改代码,优化算法,对JVM,OS,DB或系统设计或更新硬件) 6. 继续进行2步骤测试,如此循环直到达到步骤1的目标

> 系统优化注意事项: 优化前进行系统评估，在软件功能，正确性和可维护性间取得平衡，而不应该过分追求软件的性能.性能调优必须有明确目标，不要为了调优而调优，如果当前程序并没有明显的性能问题，盲目地进行调整，风险性可能远大于收益。

#### 第2章 设计优化

##### 单例模式的使用和实现.优点: 1. 对于频繁使用的对象,减少反复创建的带来的开销 2. 对于new操作次数少了，因而系统内存的使用率也会降低，减轻GC压力，缩短GC停顿时间

```java
public class Singleton implements java.io.Serialisable {
  private Singleton(){}
  private static class SingletonHolder {
    private static Singleton instance = new Singleton();
  }
  public static Singleton getInstance () {
    return SingletonHolder.instance;
  }
  //JVM反序列化地"组装"一个新对象时,会调用readResolve方法,
  private Object readResolve() {
    return SingletonHolder.instance;
  }
}
```

> 这种实现方式做到 1. 延迟加载 2. 不使用锁性能高,采用JVM类加载时创建，对多线程友好 3. 避免反序列化创建多个实例对象.

##### 代理模式的实现和深入剖析
##### 享元模式的应用
##### 装饰着模式对性能组件的封装
##### 观察者模式的使用
##### 使用`Value Object`模式减少网络数据传输
##### 使用业务代理模式添加远程调用缓存
##### 缓冲和缓存的定义和使用
##### 对象池的使用场景及其基本实现
##### 构建负载均衡系统以及`Terracotta`框架的简单使用
##### 时间换空间和空间换时间的基本思路

#### 第3章 Java程序优化

##### Java语言中字符串的优化,如何更高效利用字符串

- String对象特性:`不变性`, `针对常量池的优化`,`类的final定义`; 内部结构:`char数组`, `offset偏移`, `count长度`
  - 不变性: 一个对象状态在对象被创建之后就不再发生改变，主要作用在当一个对象需要被多线程共享，并且访问频繁时，可以省略同步和锁等待的时间，从而大幅提高系统性能。不变模式是一个可以提高多线程程序的性能，降低多线程程序复杂度的设计模式。
  - 针对常量池的优化: 当两个String对象拥有相同的值时，它们只引用常量池中的同一个拷贝，当同一个字符串反复出现时，这个技术可以大幅度节约内存空间。
  - 类的final定义: 对系统安全性的保护,JDK1.5版本之前可以提高系统效率,1.5之后效果不明显

```java
String s1 = "abc", s2 = "abc", s3 = new String("abc");
s1 == s2  //true
s1 == s3  //false
s1 == s3.intern()  //true,不同版本intern()不同
```

- subString(int beginIndex, int endIndex);底层实现是`new String(offset+beginIndex, endIndex-beginIndex, value)` 高效但是如果原字符串很大，截取的却很短，则将会有大量的内从空间浪费，甚至发生内存溢出情况，因为采用了共享原数组导致不能释放造成的。采取以空间换时间的策略.这个问题JDK1.7已修复由共享数组变成了传统的拷贝，老的JDK版本可以采用`new String(s1.substring(0,2))`这种方式获取。参考[http://www.cnblogs.com/hxy520/p/5450893.html](http://www.cnblogs.com/hxy520/p/5450893.html) [https://yq.aliyun.com/articles/232605](https://yq.aliyun.com/articles/232605)
- String[] split(String regex)简单功能强大性能不尽人意。可以使用更高效的`StringTokenizer(String str, String delim)`,`indexOf()`结合使用更高效
- 高效的`charAt()`
- `StringBuffer`同步低效和`StringBuilder`非线程安全高效。`capacity`容量可以进行初始化,当所需容量超过char数组长度，需要进行扩容，翻倍操作，然后进行`数组复制`这里如果大对象会涉及到大量内存复制操作,如果能预估出大小进行初始化，则可以有效减少因复制带来的内存消耗，从而提高系统的性能

```java
String result = "string" + "and" + "hello";//高效编译器已优化
String s1 = "string", s2 = "s2", s3 = "hello";
String s = s1 + s2 + s3;//底层编译器做的优化实现 s = (new StringBuilder(String.valueOf(s1))).append(s2).append(s3).toString();
```

##### Vector, ArrayList等核心数据结构优化方法介绍

- List:
  - ArrayList／Vector: 底层实现为对数组的操作，有扩容机制，对查询相比链表要高效，对删除或者插入操作则需要移动该元素后面的数组元素，所以性能相对会比较低,还有如果是删除的后面元素则相对前面的元素复制的元素相对少.复制采用`public static native void arraycopy(Object src,  int  srcPos,Object dest, int destPos,int length);`实现。ArrayList,线程不安全。Vector线程安全。都有扩容机制，扩容时需要做数组复制操作,调用`System.arraycopy()`.注意不同版本JDK版本实现也不同，比如JDK1.9中ArrayList的add操作是插入到最后一个数组下标中，而set操作则将是替换元素的操作。注意说特点时要有特定的上下文.
  - LinkedList采用双向循环链表作为数据结构，内存空间不连续性，相比数组占用内存空间更多比如节点的前指针后指针等。还有因为是多个节点新增时需要新建节点对象删除需要销毁，所以增加了内存以及CPU资源以及GC的开销。典型的以`空间换时间的策略`，提供了某些经常做删除或者插入操作的优势。而想要删除就要找到元素，对应的查找方式如下:

```java
public E remove(int index) { //给定下标进行删除
  checkElementIndex(index);
  return unlink(node(index));
}
/**
  * Returns the (non-null) Node at the specified element index.
*/
Node<E> node(int index) {
  // assert isElementIndex(index);
  if (index < (size >> 1)) {
      Node<E> x = first;
      for (int i = 0; i < index; i++)
          x = x.next;
      return x;
  } else {
      Node<E> x = last;
      for (int i = size - 1; i > index; i--)
          x = x.prev;
      return x;
  }
}

//给定对象进行删除操作
public boolean remove(Object o) {
  if (o == null) {
      for (Node<E> x = first; x != null; x = x.next) {
          if (x.item == null) {
              unlink(x);
              return true;
          }
      }
  } else {
      for (Node<E> x = first; x != null; x = x.next) {
          if (o.equals(x.item)) {
              unlink(x);
              return true;
          }
      }
  }
  return false;
}
```
  - ForEache遍历性能低于普通Iterator迭代器，而For循环遍历通过随机访问遍历列表时，ArraylList表现很好，对LinkedList却无法接受，这是因为对LinkedList进行随机访问时，总会进行一次列表的遍历操作。ArrayList实现了RandomAccess接口，而LinkedList没有实现。集合遍历`注意`: 对ArrayList这些基于数组的实现来说，随机访问的速度是很快的，在遍历这些List对象时，可以有限考虑随机访问。但是对于LinkedList等基于链表的实现，随机访问性能非常差，避免使用。

- Map接口：主要的实现类Hashtable,HashMap,LinkedHashMap,TreeMap,在Hashtable的子类中还有Properties类的实现.
  - HashMap，线程不安全，可以存在一个为Null的key
  - HashTable，线程安全，不能存在为Null的key，对key的Hash算法到内存索引的映射算法不同。
  - HashMap实现原理: HashMap就是将key做hash算法，然后将hash值映射到内存地址，直接取得key所对应得数据。在HashMap中，底层数据结构数组+单链表，为了解决单链表查询效率低的问题后续版本JDK引入了数组+红黑数(JKDK1.8单链表>8个时转化)，所谓的内存地址即数组得下标索引。HashMap的高性能保证了hash算法的高效，hash值到内存地址的算法快速，根据内存地址可以直接取得对应的值。移位操作以及native方法保证了性能的高效。估算容器容量，避免多次rehash以及扩容(不同版本的JDK扩容机制不同，比如高版本的有限扩容底层数组到64，然后再把单链表转红黑树结构等等，最根本的原因就是为了高性能)设置合理的负载因子，默认HashMap大小16，负载因子0.75，当HashMap超过负载因子就会进行扩容操作，维护了一个threshold变量，被定义为当前数组总容量和负载因子的乘机，HashMap的阀值。负载因子越大，需要的内存空间越小但也越容易发生hash冲突，否则反之。因此需要一个可靠的hashCode()方法，HashMap的性能一定程度上取决于hashCode()的实现.还有一些注意点比如低版本计算size，采用连续计算2次，如果相等则正确，如果不相等则产生误差。高版本JDK采用volitail变量声明的变量，size值大小更加精准。

  - LinkedHashMap-有序的HashMap,在其内部增加了一个链表，用以存放元素的顺序，因此可以理解为一个维护了元素次序表的HashMap,提供了两种类型的顺序，一是元素插入时顺序，二是最近访问的顺序。
  - 注意:不要在迭代器模式中修改被迭代的集合。如果这么做，会抛出`ConcurrentModificationException`异常,这个特性适用于所有集合类，包括HashMap,Vector,ArrayList等
  - TreeMap：排序方式与LinkedHashMap不同，LinkedHashMap是基于元素进入集合的顺序或者被访问的先后顺序排序的，而TreeMap是基于元素的固有顺序(由Comparator或者Comparable确定)

- Set接口:
  - 不重复，内部实现为HashMap的一种封装。

- 优化集合访问代码
  1. 分离循环中被重复调用的代码.如下举例:

```java
for (int i = 0; i < collection.size(); i++) {
  //todo
}
//修改为如下
int size = collection.size();
for (int i = 0; i < size; i++) {
  //todo
}
```
 2. 省略相同的操作
 3. 减少方法调用，改为直接访问元素会更高效。因为函数调用是需要消耗大量的系统资源的。

- RandomAccess接口:一个标志接口，表示支持快速随机访问的对象。主要目的是标识可以支持快速随机访问的List的实现，JDK中，任何基于数组的List实现都实现了RandomAccess接口，而对链表的的实现则没有，因为数组能够进行快速随机访问，而链表的随机访问需要进行链表的遍历。如下:

```java
if (list instanceof RandomAccess) {
  for (int i = 0, size = list.size(); i < size; i++) {
    Object obj = list.get(i);//通过下标随机高效访问，底层为数组实现RandomAccess接口
    //todo 
  }
} else {
  Iterator iterator = list.iterator();
  while (iterator.hasNext()) {
    Object object = iterator.next(); 
    //todo
  }
}
```


##### 在Java语言中使用NIO提高I/O性能摆脱最大堆束缚

- NIO是JDK1.4被纳入，特征:
  - 为所有的原始类型提供Buffer缓存支持
  - 使用Java.nio.charset.Charset作为字节集编码解决方案
  - 增加通道Channel对象，作为新的原始I/O抽象
  - 支持锁和内存映射文件的文件访问接口
  - 提供基于Selector的异步网络I/O

- Buffer 3个重要参数:位置position, 容量capactiy,上限limit,分别有读写两种模式,读/写时position/limit会发生变化
- 使用MaxDirectMemorySize可以指定DirectBuffer的最大可用空间，DirectBuffer的缓存空间不再堆上分配，因此可以使应用程序突破最大堆的内存限制，堆DirectBuffer的读写操作比普通Buffer快，但是对它的创建和销毁却比普通Buffer慢。


##### 在Java中的应用类型和使用方法

- 4个级别的引用:强引用，软引用，弱引用和虚引用
  - 强引用:可以直接访问对象，不会被系统回收JVM宁愿抛出OOM异常，可能导致内存泄漏。
  - 软引用:JVM会根据当前堆的使用情况来判断何时回收软引用对象，当堆使用情况临近阀值，才会回收软引用对象，若内存足够，软引用可能在内存中存活相当长一段时间，因此软引用可以用于实现对内存敏感的Cache
  - 弱引用:只要系统GC时发现弱引用就会进行回收，无论堆空间是否足够。
  - 虚引用:持有虚引用的对象和没有引用几乎一样，随时都可能被GC回收，当试图通过虚引用的get()取得强引用时，总是失败

##### 一些有助于提高系统性能的技巧

- 慎用异常，比如循环体内使用try{}catch(Exception e){}
- 使用局部变量,局部变量都是保存在栈中，速度快，而静态变量，实例变量，都在堆中创建，速度慢。局部变量访问速度一般高于类的成员变量。
- 位运算代替乘除法
- 替换switch语句，比如数组可能可以是一种思路
- 一维数组代替二维数组
- 提取表达式，即重复工作抽出来做一次就可以
- 展开循环，例子如下:

```java
int[] array = new int[99999];
for (int i = 0; i < 99999; i++) {
  array[i] = i;
}
//展开循环
for (inti i = 0; i < 99999; i+=3) {
  array[i] = i;
  array[i+1] = i+1;
  array[i+2] = i+2;
}
```

- 布尔运算代替位运算
- 数组复制使用`System.arraycopy(....)`
- 使用Buffer进行I/O操作
- `使用clone()代替new`,clone()默认浅层拷贝
- 静态方法替代实例方法

#### 第4章 并行程序开发及优化

##### 4.1 并行程序设计模式
- `Future`模式
- `Master-Worker`模式是常用的并行模式之一，核心思想是，系统由两类进行协作，Master进行负责接收和分配任务，Worker进行负责处理子任务，当各个Worker进行将子任务处理完成后，将结果返回给Master进行，由Master进程做归纳和汇总，从而得到系统的最终结果。将一个大任务分解成若干个小任务，并行执行，提高系统吞吐量，对client来说异步处理，不会出现等待现象
- `Guarded Suspension模式`意为保护暂停，其核心思想是仅当服务进程准好时，才提供服务。确保系统仅在有能力处理某个任务时，才处理该任务，当系统没有能力处理任务时，它将暂存任务信息比如队列或MQ中，等待系统空闲。起到消峰平谷的作用。
- `不变模式`在并行软件开发过程中，同步操作似乎必不可少，当多线程对同一个对象进行读写操作时，为了保证对象数据的一致性和正确性，有必要对对象进行同步，而同步操作对系统性能有相当的损耗。为了能尽可能去除这些同步操作，提高并行程序性能，可以使用一种`不变对象`，依靠对象的不变性，可以确保其在没有同步操作的多线程环境中依然始终保持内部状态的一致性和正确性。核心思想就是，一个对象一旦被创建，则它的内部状态将永远不会发生改变，所以没有一个线程可以修改其内部状态和数据，基于这个特性，不变性对象在多线程环境中不需要进行同步控制。注意，不变模式比只读具有更强的一致性和不变性。对只读属性的对象而言，对象本身不能被其他线程修改，但是对象的自身状态却可能被自身自行修改。注意如下可以做到不变模式：
  - 去除setter方法及其所有修改自身属性的方法
  - 将所有属性设置为私有并用final标记，确保不可修改
  - 确保没有子类可以重载修改它的行为
  - 有一个可以创建完整对象的构造函数
  - 综上保证对象创建后其内部状态和数据不再发生变化，可以被共享被多线程频繁访问。比如JDK中的`java.lang.String/Boolean/Byte/Character/Double/Float/Integer/Long/Short`等保证多线程下的性能和吞吐量
- `生产者-消费者模式`：通过内存缓冲在多线程间共享数据，还可以缓解生产者和消费者间的性能差，同时也要注意是否差的太多。还可以进行`解耦`优化系统整体结构，一定程度地缓解性能差对系统性能的影响。
- JDK多任务执行框架:`Executor`框架，自定以线程池如下:

```java
public ThreadPoolExecutor(int corePoolSize,
			  int maximumPoolSize,
			  long keepAliveTime,
			  TimeUnit unit,
			  BlockingQueue<Runable> workQueue,
			  ThreadFactory threadFactory,
			  RejectedExecutionHandler handler)
//函数参数含义如下:
corePoolSize: 线程池核心线程数量
maximumPoolSize: 线程池最大线程数量
keepAliveTime: 当线程池线程数量超过corePoolSize时,多余的空闲线程的存活时间,即超过corePoolSize的空闲线程在多长时间内会被销毁
unit: keepAliveTime的单位
workQueue: 任务队列，被提交但尚未执行的任务
threadFactory: 线程工厂,用于创建线程，一般默认即可
handler: 拒绝策略,当任务太多，如何进行拒绝任务
```

- 一些注意点针对有界队列而言: 
  1. 如果线程池的实际线程数小于corePoolSize则优先创建新的线程
  2. 若大于corePoolSize则会将新任务加入等待队列
  3. 若等待队列已满，无法加入，则在总线程数不大于maximumPoolSize的前提下，创建新的进程执行任务。
  4. 若大于maximumPoolSize则执行拒绝策略
  - 可见有界队列仅当任务队列满时才可能将线程数量提升到corePoolSize以上，换言之除非系统非常繁忙，否则确保核心线程数维持在corePoolSize，队列未满先放队列，也更好利用线程达到线程的目的，如果先创建线程则会多GC，多线程间的切换，性能影响。如果是无界队列，则会存在内存耗尽情况，危险。以及还有优先级的队列`PriorityBlockingQueue`主要还是根据业务需要。多次测试，调corePoolSize,以及maximumPoolSize才能达到最优。
- JDK内置拒绝策略:
  - AbortPolicy：直接抛出异常，阻止系统正常工作
  - CallerRunPolicy: 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务
  - DiscardOledestPlicy: 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务
  - DiscardPolicy: 默默丢系无法处理的任务不予任何处理
  - 可以自定义实现`RejectedExecutionHandler`接口

- 优化线程大小经验，一般与CPU数量,内存大小,JDBC连接等因素,如下:
  - Ncpu=CPU数量; Ucpu=目标CPU使用率,0<=Ucpu<=1; W/C=等待时间与计算时间的比率
  - 为保持处理器达到期望使用率，最优线程池大小等于:`Nthreads=Ncpu*Ucpu*(1+W/C)`,`Ncpu=Runtime.getRuntime().availableProcessors()`获取CPU数量

- 扩展`ThreadPoolExecutor`

##### JDK并发数据结构
- 并发List,`CopyOnWriteArrayList/Vector/Collections.synchronizedList(List list)`，在读多写少的高并发环境中优先使用`CopyOnWriteArrayList`可提高系统性能吞吐量，在写多读少`CopyOnWriteArrayList`的性能可能不如`Vector`
- 并发Set,`CopyOnWriteArraySet`场景同上
- 并发Map,`ConcurrentHashMap`分段锁
- 并发Queue,`ConcurrentLinkedQueue`
- 并发Deque,`LinkedBlockingDeque`

##### 并发控制方法
- 内存模型与`volatile`
- 工作内存执行操作:`use,assign,load,store`
- 主内存执行的操作:`read,write,lock,unlock`都是原子操作
- 






