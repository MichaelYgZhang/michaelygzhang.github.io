---
layout: post
title: 七周七并发模型
excerpt: 七周七并发模型
category: Destributed
---

#### 第1章 概述
- 1.1 并发还是并行
  - 并发：同一时间应对多件事情的能力；
  - 并行：同一时间动手做多件事情的能力；
- 1.2 并行架构
  - 位级(bit-level)并行
  - 指令级(instruction-level)并行
  - 数据级(data)并行
  - 人物级(task-level)并行
- 1.3 并发: 不只是多核
  - 并发的世界，并发的软件
  - 分布式的世界，分布式的软件
  - 不可预测的世界，容错性强的软件
  - 复杂的世界，简单的软件
- 1.4 七个模型
  - 线程与锁
  - 函数式变成
  - Clojure之道--分离标识与状态
  - 通信顺序进程(Communicating Sequential Processes CSP)
  - 数据级并行
  - Lambda架构

#### 第2章 线程与锁
- 2.1 简单粗暴
- 2.2 第一天:互斥和内存模型
  - 编译器的静态优化看打乱代码的执行顺序；
  - JVM的动态优化也会打乱代码的执行顺序
  - 硬件可以通过乱序执行来优化其性能.
  - 线程与锁模型带来的三个主要危害---竞态条件，死锁和内存可见性，可以利用如下准则避免危害:
    - 对共享变量的所有访问都需要同步化
    - 读线程和写线程都需要同步化
    - 按照约定的全局顺序来获取多把锁
    - 当持有锁时避免调用外星方法
    - 持有锁的时间应尽可能短
- 2.3 第二天:超越内置锁
  - 内置锁的缺点:
    - 一个线程因为等待内置锁而进入阻塞之后，就无法中断该线程了。
    - 尝试获取内置锁时，无法设置超时
    - 获得内置锁，必须使用`synchronized`块
    - 获取锁和释放锁的代码必须严格嵌在同一个方法中。另外声明`synchronized`的函数其实只是一个"语法糖"

```java
synchronized (object) {
  //使用共享资源
}
//等价
synchronized (this) {
 //函数体
}
```

- `ReentrantLock`

```java
ReentrantLock lock = new ReentrantLock();
Condition condition = lock.newCondition();
lock.lock();
try {
  while (!<条件为真>){
    condition.await()
  }

  //使用共享资源
} finally {
  lock.unlock();
}
//其他地方需要调用 signal()/signalAll()
```

- `volatile`：随着JVM被不断优化，其提供了一些低开销的锁，volatile变量的适用场景也越来越少。如果你考虑使用volatile，也许应当在`java.util.concurrent.atomic`包中寻找更合适的工具

- 总结:`ReentrantLock`和`java.util.concurrent.atomic`突破了使用内置锁的限制，利用新工具类可以做到:
  - 在线程获取锁时中断它；
  - 设置线程获取锁的超时时间；
  - 按任意顺序获取和释放锁；
  - 用条件变量等待某个条件变为真;
  - 使用原子变量避免锁的使用；

- 第三天:站在巨人的肩膀上
  - `java.util.concurrent`包提供的工具不仅让并发编程更容易而且在以下方面让程序更安全高效：
    - 使用线程池，而不是直接创建线程
    - 使用`CopyOnWriteArrayList`
    - 使用`ArrayBlockingQueue`让生产者和消费者之前高效协作；
    - `ConcurrentHashMap`提供了更好的并发访问
    - `ForkJoinPoll`,`CountDownLatch`,`CyclicBarrier`,`work-stealing`

#### 第3章 函数式编程
- 3.2 第一天：抛弃可变状态
- 可变状态的风险
  - 隐藏的可变状态
  - 逃逸的可变状态
- `Clojure`旋风之旅:

```clojure
~ clj
Clojure 1.9.0
user=> (+ 1 2)
3
user=> (max 3 4)
4
user=> (max 2 5)
5
user=> (+ 1 (* 2 3))
7
user=> (def meaning-of-life 42)
#'user/meaning-of-life
user=> meaning-of-life
42
user=> (if (< meaning-of-life 0) "negative" "non-negative")
"non-negative"
user=> (def droids ["Huey" "Dewey" "Louie"])
#'user/droids
user=> (count droids)
3
user=> (droids 0)
"Huey"
user=> (droids 2)
"Louie"
user=> (def me {:name "Paul" :age 45 :sex :male})
#'user/me
user=> (:age me)
45
user=> (:name me)
"Paul"
user=> (defn percentage [x p] (* x (/ p 100.0)))
#'user/percentage
user=> (percentage 200 10)
20.0
user=>
```

- 下面举例说明函数式编程最有趣的地方时不使用可变状态：数列求和

- Java代码

```java
public int sum( int[] numbers) { 
  int accumulator = 0; 
  for (int n: numbers) 
    accumulator += n; 
  return accumulator; 
}
```

- Clojure

```clojure
//V1
(defn recursive- sum [numbers] 
  (if (empty? numbers) 
    0 
    (+ (first numbers) (recursive- sum (rest numbers)))))

//V2
(defn reduce- sum [numbers] 
  (reduce (fn [acc x] (+ acc x)) 0 numbers))

//V3
(defn sum [numbers] 
  (reduce + numbers))
```

- clojure操作符特性

```clojure
user=> (+)
0
user=> (*)
1
user=> (/)
ArityException Wrong number of args (0) passed to: core//  clojure.lang.AFn.throwArity (AFn.java:429)
user=> (-)
ArityException Wrong number of args (0) passed to: core/-  clojure.lang.AFn.throwArity (AFn.java:429)
user=>
```

- 并行

```clojure
(ns sum. core 
  (:require [clojure. core. reducers :as r])) 
(defn parallel- sum [numbers] 
  (r/fold + numbers))
//todo 性能分析
```

- 

// TODO 需要先学以下Clojure然后继续阅读

#### 第6章 通信顺序金正
- 
