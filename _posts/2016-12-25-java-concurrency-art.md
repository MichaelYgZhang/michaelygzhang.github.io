---
layout: post
title: Java并发编程艺术-读书笔记
excerpt: Java并发编程艺术
category: Java
---

##### 1 并发编程的挑战

- 上下文切换，减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。
- 死锁，避免死锁的常见方法，避免一个线程同时获取多个锁；避免一个线程在锁内同时占用多个资源，尽量
  保证每个锁只占用一个资源；尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制；
  对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。
- 资源限制，可以通过增加集群解决，具体问题具体分析

##### 2 Java并发机制的底层实现原理

- `volatile` 多线程共享变量的可见性，不保证原子性。比`synchronized`的执行成本更低，因为它不会引起线程上下文的切换和调度。实现机制：1. volatile变量生成字节码中，在写之前有lock，lock前缀指令会引起处理器缓存回写到内存，
并且有会有个称为“缓存锁定”的操作，这个缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。2. 一个处理器缓存回写到内存会导致其他处理器的缓存无效。
- `synchronized`的实现原理与应用。每个对象对应会有一对Monitor，monitorenter/monitorexit
  1. 普通同步方法，锁的是当前实例对象。
  2. 对于静态同步方法，锁是当前类的Class对象。
  3. 对于同步方法块，锁的是'synchronized'括号里的对象。

锁 | 优点| 缺点| 使用场景 |
:--|:---|:----|:--------|
偏向锁|加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级差距|线程存在锁竞争带来额外的锁撤销的消耗|适用于只有一个线程访问同步块场景。|
轻量级锁| 竞争的线程不会阻塞，提高程序的响应速度|如果程序始终得不到锁竞争的线程使用自旋会消耗CPU|追求响应时间同步块执行速度非常快|
重量级锁|线程竞争不使用自旋,不会消耗CPU|线程阻塞，响应时间缓慢|追求吞吐量同步块执行速度较长|

- 原子操作的实现原理
